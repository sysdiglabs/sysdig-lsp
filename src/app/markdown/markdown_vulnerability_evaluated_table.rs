use std::{
    fmt::{Display, Formatter},
    sync::Arc,
};

use itertools::Itertools;
use markdown_table::{Heading, HeadingAlignment, MarkdownTable};

use crate::domain::scanresult::{layer::Layer, scan_result::ScanResult};

#[derive(Clone, Debug, Default)]
pub struct VulnerabilityEvaluated {
    pub cve: String,
    pub severity: String,
    pub packages_found: u32,
    pub fixable: bool,
    pub exploitable: bool,
    pub accepted_risk: bool,
}

#[derive(Clone, Debug, Default)]
pub struct VulnerabilityEvaluatedTable(pub Vec<VulnerabilityEvaluated>);

impl From<&ScanResult> for VulnerabilityEvaluatedTable {
    fn from(value: &ScanResult) -> Self {
        VulnerabilityEvaluatedTable(
            value
                .vulnerabilities()
                .iter()
                .sorted_by_key(|v| v.cve())
                .sorted_by(|a, b| {
                    b.found_in_packages()
                        .len()
                        .cmp(&a.found_in_packages().len())
                })
                .sorted_by(|a, b| b.fixable().cmp(&a.fixable()))
                .sorted_by(|a, b| b.exploitable().cmp(&a.exploitable()))
                .sorted_by_key(|v| v.severity())
                .map(|v| VulnerabilityEvaluated {
                    cve: v.cve().to_string(),
                    severity: v.severity().to_string(),
                    packages_found: v.found_in_packages().len() as u32,
                    fixable: v.fixable(),
                    exploitable: v.exploitable(),
                    accepted_risk: !v.accepted_risks().is_empty(),
                })
                .collect(),
        )
    }
}
impl From<&Arc<Layer>> for VulnerabilityEvaluatedTable {
    fn from(value: &Arc<Layer>) -> Self {
        VulnerabilityEvaluatedTable(
            value
                .vulnerabilities()
                .iter()
                .sorted_by_key(|v| v.cve())
                .sorted_by(|a, b| {
                    b.found_in_packages()
                        .len()
                        .cmp(&a.found_in_packages().len())
                })
                .sorted_by(|a, b| b.fixable().cmp(&a.fixable()))
                .sorted_by(|a, b| b.exploitable().cmp(&a.exploitable()))
                .sorted_by_key(|v| v.severity())
                .map(|v| VulnerabilityEvaluated {
                    cve: v.cve().to_string(),
                    severity: v.severity().to_string(),
                    packages_found: v.found_in_packages().len() as u32,
                    fixable: v.fixable(),
                    exploitable: v.exploitable(),
                    accepted_risk: !v.accepted_risks().is_empty(),
                })
                .collect(),
        )
    }
}

impl Display for VulnerabilityEvaluatedTable {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        if self.0.is_empty() {
            return f.write_str("");
        }

        let headers = vec![
            Heading::new("VULN CVE".to_string(), Some(HeadingAlignment::Left)),
            Heading::new("SEVERITY".to_string(), Some(HeadingAlignment::Left)),
            Heading::new("PACKAGES".to_string(), Some(HeadingAlignment::Left)),
            Heading::new("FIXABLE".to_string(), Some(HeadingAlignment::Left)),
            Heading::new("EXPLOITABLE".to_string(), Some(HeadingAlignment::Left)),
            Heading::new("ACCEPTED RISK".to_string(), Some(HeadingAlignment::Left)),
        ];

        let data = self
            .0
            .iter()
            .map(|v| {
                vec![
                    v.cve.clone(),
                    v.severity.clone(),
                    v.packages_found.to_string(),
                    if v.fixable { "✅" } else { "❌" }.to_string(),
                    if v.exploitable { "✅" } else { "❌" }.to_string(),
                    if v.accepted_risk { "✅" } else { "❌" }.to_string(),
                ]
            })
            .collect();

        let mut table = MarkdownTable::new(data);
        table.with_headings(headers);

        let format = format!(
            "\n### Vulnerability Detail\n\n{}",
            table.as_markdown().unwrap_or_default()
        );

        f.write_str(&format)
    }
}
