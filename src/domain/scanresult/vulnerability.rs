use crate::domain::scanresult::accepted_risk::AcceptedRisk;
use crate::domain::scanresult::layer::Layer;
use crate::domain::scanresult::package::Package;
use crate::domain::scanresult::severity::Severity;
use crate::domain::scanresult::weak_hash::WeakHash;
use chrono::{DateTime, Utc};
use std::collections::HashSet;
use std::fmt::Debug;
use std::hash::{Hash, Hasher};
use std::sync::{Arc, RwLock};

pub struct Vulnerability {
    cve: String,
    severity: Severity,
    disclosure_date: DateTime<Utc>,
    solution_date: Option<DateTime<Utc>>,
    exploitable: bool,
    fix_version: Option<String>,
    found_in_packages: RwLock<HashSet<WeakHash<Package>>>,
    accepted_risks: RwLock<HashSet<WeakHash<AcceptedRisk>>>,
}

impl Debug for Vulnerability {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Vulnerability")
            .field("cve", &self.cve)
            .field("severity", &self.severity)
            .field("disclosure_date", &self.disclosure_date)
            .field("solution_date", &self.solution_date)
            .field("exploitable", &self.exploitable)
            .field("fix_version", &self.fix_version)
            .finish()
    }
}

impl Vulnerability {
    pub(in crate::domain::scanresult) fn new(
        cve: String,
        severity: Severity,
        disclosure_date: DateTime<Utc>,
        solution_date: Option<DateTime<Utc>>,
        exploitable: bool,
        fix_version: Option<String>,
    ) -> Self {
        Self {
            cve,
            severity,
            disclosure_date,
            solution_date,
            exploitable,
            fix_version,
            found_in_packages: RwLock::new(HashSet::new()),
            accepted_risks: RwLock::new(HashSet::new()),
        }
    }

    pub fn cve(&self) -> &str {
        &self.cve
    }

    pub fn severity(&self) -> Severity {
        self.severity
    }

    pub fn disclosure_date(&self) -> DateTime<Utc> {
        self.disclosure_date
    }

    pub fn solution_date(&self) -> Option<DateTime<Utc>> {
        self.solution_date
    }

    pub fn exploitable(&self) -> bool {
        self.exploitable
    }

    pub fn fixable(&self) -> bool {
        self.fix_version.is_some()
    }

    pub fn fix_version(&self) -> Option<&str> {
        self.fix_version.as_deref()
    }

    pub(in crate::domain::scanresult) fn add_found_in_package(
        self: &Arc<Self>,
        a_package: Arc<Package>,
    ) {
        if self
            .found_in_packages
            .write()
            .unwrap()
            .insert(WeakHash(Arc::downgrade(&a_package)))
        {
            a_package.add_vulnerability_found(self.clone());
        }
    }

    pub fn found_in_packages(&self) -> Vec<Arc<Package>> {
        self.found_in_packages
            .read()
            .unwrap()
            .iter()
            .filter_map(|p| p.0.upgrade())
            .collect()
    }

    pub fn found_in_layers(&self) -> Vec<Arc<Layer>> {
        self.found_in_packages()
            .iter()
            .map(|p| p.found_in_layer())
            .cloned()
            .collect()
    }

    pub(in crate::domain::scanresult) fn add_accepted_risk(
        self: &Arc<Self>,
        accepted_risk: Arc<AcceptedRisk>,
    ) {
        if self
            .accepted_risks
            .write()
            .unwrap()
            .insert(WeakHash(Arc::downgrade(&accepted_risk)))
        {
            accepted_risk.add_for_vulnerability(self.clone());
        }
    }

    pub fn accepted_risks(&self) -> Vec<Arc<AcceptedRisk>> {
        self.accepted_risks
            .read()
            .unwrap()
            .iter()
            .filter_map(|r| r.0.upgrade())
            .collect()
    }
}

impl PartialEq for Vulnerability {
    fn eq(&self, other: &Self) -> bool {
        self.cve == other.cve
    }
}

impl Eq for Vulnerability {}

impl Hash for Vulnerability {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.cve.hash(state);
    }
}
